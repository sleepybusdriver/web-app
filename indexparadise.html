<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Paradise Hell Rewards — Interactive Tables</title>
    <style>
        :root {
            --gap: 12px;
            --radius: 8px
        }

        body {
            font-family: Inter, system-ui, Arial;
            margin: 20px;
            background: #f6f7fb;
            color: #111
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 18px
        }

        .tab {
            padding: 8px 14px;
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(16, 24, 40, .06)
        }

        .tab.active {
            background: linear-gradient(180deg, #eef7ff, #e6f2ff);
            border: 1px solid #cfe8ff
        }

        .card {
            background: #fff;
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(16, 24, 40, .06)
        }

        .table-wrapper {
            overflow-x: auto;
            padding-top: 8px
        }

        table {
            width: max-content;
            min-width: 100%;
            border-collapse: collapse;
            margin-top: 12px
        }

        th,
        td {
            padding: 8px 10px;
            border-bottom: 1px solid #eceff4;
            text-align: center;
            vertical-align: middle
        }

        th.header-input {
            white-space: nowrap;
            padding: 8px 10px;
            text-align: center
        }

        input.market {
            width: 100px;
            padding: 6px;
            border-radius: 6px;
            border: 1px solid #d0d6e0
        }

        .small {
            font-size: 12px;
            color: #667085
        }

        .cell-count {
            font-weight: 600
        }

        .cell-value {
            display: block;
            font-size: 12px;
            color: #0f172a;
            margin-top: 6px
        }

        .row-total {
            font-weight: 700
        }

        .heat {
            border-radius: 6px;
            padding: 6px
        }

        .legend {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 10px
        }

        .legend .box {
            width: 20px;
            height: 12px;
            border-radius: 4px
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap
        }

        .note {
            font-size: 13px;
            color: #475569;
            margin-top: 12px
        }
    </style>
</head>

<body>
    <h2>Paradise — Hell Rewards (interactive)</h2>
    <p class="small">3 tabs for the 3 Item Level reward tables. Add real table data into the <code>TABLE_DATA</code>
        variable in the script (see comments) and the UI will auto-calculate MarketValue * Count and highlight best
        per-row values.</p>

    <div class="tabs" id="tabs"></div>
    <div class="card" id="card"></div>

    <script>
        /* -----------------------
           HOW THIS WORKS
           - Replace the placeholder TABLE_DATA below with the exact data from the maxroll page.
           - Structure: TABLE_DATA = [{title: 'Item level 1640', columns:[{key:'leapstones', label:'Leapstones'},{...}], rows:[{label:'Floor 1-9', cells:{leapstones:45, fusions:60, shards:8000, juicers: '6/18', gold:3200}}, ...] }, ...]
           - If a cell contains several materials (e.g. "6 / 18" meaning two numbers), put them as an array or add them into the same column as a sum (the script supports numbers or arrays).
           - Header inputs: put the market value per column (number). The script will multiply market*count and show the computed value under the count.
           - If a column cell contains multiple materials (different materials but same column), simply set the cell to the sum number you want multiplied.
      
           The file below is a fully working UI. If you want me to extract the data from the maxroll page, paste the three tables here or allow me access to the page.
        ----------------------- */

        // ====== REAL DATA FROM SOURCES ======
        const TABLE_DATA = [
            {
                title: 'Item level 1580',
                columns: [
                    { key: 'honing_red_blue_t3', label: 'Honing Materials (Red / Blue)' },
                    { key: 'leapstones_t3', label: 'Leapstones' },
                    { key: 'fusions_t3', label: 'Fusions' },
                    { key: 'shards_t3', label: 'Shards' },
                    { key: 'juicers_t3', label: 'Juicers (Grace / Blessing / Protection)' },
                    { key: 'gold', label: 'Bound Gold' },
                    { key: 'silver', label: 'Silver' },
                    { key: 'quality_taps', label: 'Quality Taps (Wep / Armor)' },
                    { key: 'circulated_t3', label: 'Circulated Leapstones' }
                ],
                rows: [
                    { label: 'Floor 1-9', cells: { honing_red_blue_t3: [2500, 7500], leapstones_t3: 80, fusions_t3: 75, shards_t3: 18000, juicers_t3: [144, 48, 24], gold: 2500, silver: 500000, quality_taps: [7, 7], circulated_t3: 40 } },
                    { label: 'Floor 10-19', cells: { honing_red_blue_t3: [3600, 10800], leapstones_t3: 120, fusions_t3: 125, shards_t3: 27000, juicers_t3: [216, 72, 36], gold: 4000, silver: 1000000, quality_taps: [10, 10], circulated_t3: 60 } },
                    { label: 'Floor 20-29', cells: { honing_red_blue_t3: [5000, 15000], leapstones_t3: 160, fusions_t3: 150, shards_t3: 36000, juicers_t3: [324, 108, 54], gold: 5500, silver: 1500000, quality_taps: [15, 15], circulated_t3: 80 } },
                    { label: 'Floor 30-39', cells: { honing_red_blue_t3: [6500, 19500], leapstones_t3: 200, fusions_t3: 200, shards_t3: 45000, juicers_t3: [360, 120, 60], gold: 6500, silver: 2000000, quality_taps: [20, 20], circulated_t3: 100 } },
                    { label: 'Floor 40-49', cells: { honing_red_blue_t3: [9500, 28500], leapstones_t3: 300, fusions_t3: 300, shards_t3: 70000, juicers_t3: [576, 192, 96], gold: 10000, silver: 2500000, quality_taps: [27, 27], circulated_t3: 150 } },
                    { label: 'Floor 50-59', cells: { honing_red_blue_t3: [12500, 37500], leapstones_t3: 400, fusions_t3: 400, shards_t3: 90000, juicers_t3: [792, 264, 132], gold: 13000, silver: 3000000, quality_taps: [36, 36], circulated_t3: 200 } },
                    { label: 'Floor 60-69', cells: { honing_red_blue_t3: [18000, 54000], leapstones_t3: 600, fusions_t3: 600, shards_t3: 135000, juicers_t3: [1152, 384, 192], gold: 19500, silver: 5000000, quality_taps: [54, 54], circulated_t3: 300 } },
                    { label: 'Floor 70-79', cells: { honing_red_blue_t3: [25000, 75000], leapstones_t3: 800, fusions_t3: 800, shards_t3: 180000, juicers_t3: [1620, 540, 270], gold: 26000, silver: 6000000, quality_taps: [72, 72], circulated_t3: 400 } },
                    { label: 'Floor 80-89', cells: { honing_red_blue_t3: [35000, 105000], leapstones_t3: 1000, fusions_t3: 1000, shards_t3: 250000, juicers_t3: [2160, 720, 360], gold: 36000, silver: 8000000, quality_taps: [100, 100], circulated_t3: 600 } },
                    { label: 'Floor 90-99', cells: { honing_red_blue_t3: [50000, 150000], leapstones_t3: 1600, fusions_t3: 1600, shards_t3: 360000, juicers_t3: [3060, 1020, 510], gold: 42000, silver: 10000000, quality_taps: [144, 144], circulated_t3: 800 } },
                    { label: 'Floor 100', cells: { honing_red_blue_t3: [65000, 255000], leapstones_t3: 2600, fusions_t3: 2600, shards_t3: 600000, juicers_t3: [5220, 1740, 870], gold: 78000, silver: 20000000, quality_taps: [250, 250], circulated_t3: 1400 } }
                ]
            },
            {
                title: 'Item level 1640',
                columns: [
                    { key: 'honing_red_blue', label: 'Honing Materials (Red / Blue)' },
                    { key: 'leapstones', label: 'Leapstones' },
                    { key: 'fusions', label: 'Fusions' },
                    { key: 'shards', label: 'Shards' },
                    { key: 'juicers', label: 'Juicers (Lava / Glacier)' },
                    { key: 'gold', label: 'Bound Gold' },
                    { key: 'silver', label: 'Silver' },
                    { key: 'quality_taps', label: 'Quality Taps (Wep / Armor)' },
                    { key: 'circulated', label: 'Circulated Leapstones' }
                ],
                rows: [
                    { label: 'Floor 1-9', cells: { honing_red_blue: [1000, 3000], leapstones: 45, fusions: 60, shards: 8000, juicers: [6, 18], gold: 3200, silver: 500000, quality_taps: [7, 7], circulated: 60 } },
                    { label: 'Floor 10-19', cells: { honing_red_blue: [1500, 4500], leapstones: 70, fusions: 90, shards: 12000, juicers: [9, 27], gold: 4800, silver: 1000000, quality_taps: [10, 10], circulated: 90 } },
                    { label: 'Floor 20-29', cells: { honing_red_blue: [2000, 6000], leapstones: 90, fusions: 125, shards: 16000, juicers: [12, 36], gold: 6400, silver: 1500000, quality_taps: [15, 15], circulated: 130 } },
                    { label: 'Floor 30-39', cells: { honing_red_blue: [2500, 7500], leapstones: 120, fusions: 150, shards: 20000, juicers: [15, 45], gold: 8000, silver: 2000000, quality_taps: [20, 20], circulated: 160 } },
                    { label: 'Floor 40-49', cells: { honing_red_blue: [3500, 10500], leapstones: 180, fusions: 225, shards: 30000, juicers: [22, 66], gold: 12000, silver: 2500000, quality_taps: [27, 27], circulated: 200 } },
                    { label: 'Floor 50-59', cells: { honing_red_blue: [5000, 15000], leapstones: 240, fusions: 300, shards: 40000, juicers: [30, 90], gold: 16000, silver: 3000000, quality_taps: [36, 36], circulated: 320 } },
                    { label: 'Floor 60-69', cells: { honing_red_blue: [7500, 22500], leapstones: 350, fusions: 450, shards: 60000, juicers: [45, 135], gold: 24000, silver: 5000000, quality_taps: [54, 54], circulated: 450 } },
                    { label: 'Floor 70-79', cells: { honing_red_blue: [10000, 30000], leapstones: 480, fusions: 600, shards: 80000, juicers: [58, 174], gold: 32000, silver: 6000000, quality_taps: [72, 72], circulated: 650 } },
                    { label: 'Floor 80-89', cells: { honing_red_blue: [15000, 45000], leapstones: 650, fusions: 850, shards: 108000, juicers: [80, 240], gold: 44000, silver: 8000000, quality_taps: [100, 100], circulated: 850 } },
                    { label: 'Floor 90-99', cells: { honing_red_blue: [20000, 60000], leapstones: 950, fusions: 1200, shards: 160000, juicers: [120, 360], gold: 64000, silver: 10000000, quality_taps: [144, 144], circulated: 1250 } },
                    { label: 'Floor 100', cells: { honing_red_blue: [35000, 105000], leapstones: 1600, fusions: 2000, shards: 260000, juicers: [190, 570], gold: 96000, silver: 20000000, quality_taps: [250, 250], circulated: 2100 } }
                ]
            },
            {
                title: 'Item level 1680',
                columns: [
                    { key: 'honing_red_blue', label: 'Honing Materials (Red / Blue)' },
                    { key: 'leapstones', label: 'Leapstones' },
                    { key: 'fusions', label: 'Fusions' },
                    { key: 'shards', label: 'Shards' },
                    { key: 'juicers', label: 'Juicers (Lava / Glacier)' },
                    { key: 'gold', label: 'Bound Gold' },
                    { key: 'silver', label: 'Silver' },
                    { key: 'quality_taps', label: 'Quality Taps (Wep / Armor)' },
                    { key: 'circulated', label: 'Circulated Leapstones' }
                ],
                rows: [
                    { label: 'Floor 1-9', cells: { honing_red_blue: [1800, 5400], leapstones: 70, fusions: 85, shards: 12000, juicers: [8, 24], gold: 3500, silver: 500000, quality_taps: [7, 7], circulated: 80 } },
                    { label: 'Floor 10-19', cells: { honing_red_blue: [2500, 7500], leapstones: 100, fusions: 125, shards: 16000, juicers: [23, 36], gold: 5500, silver: 1000000, quality_taps: [10, 10], circulated: 130 } },
                    { label: 'Floor 20-29', cells: { honing_red_blue: [3500, 10500], leapstones: 140, fusions: 165, shards: 21000, juicers: [15, 45], gold: 7500, silver: 1500000, quality_taps: [15, 15], circulated: 180 } },
                    { label: 'Floor 30-39', cells: { honing_red_blue: [4200, 12600], leapstones: 180, fusions: 210, shards: 27000, juicers: [20, 60], gold: 9000, silver: 2000000, quality_taps: [20, 20], circulated: 210 } },
                    { label: 'Floor 40-49', cells: { honing_red_blue: [6400, 19200], leapstones: 270, fusions: 310, shards: 42000, juicers: [30, 90], gold: 13500, silver: 2500000, quality_taps: [27, 27], circulated: 320 } },
                    { label: 'Floor 50-59', cells: { honing_red_blue: [8500, 25500], leapstones: 360, fusions: 415, shards: 56000, juicers: [40, 120], gold: 18000, silver: 3000000, quality_taps: [36, 36], circulated: 430 } },
                    { label: 'Floor 60-69', cells: { honing_red_blue: [12000, 36000], leapstones: 540, fusions: 630, shards: 84000, juicers: [60, 180], gold: 27000, silver: 5000000, quality_taps: [54, 54], circulated: 650 } },
                    { label: 'Floor 70-79', cells: { honing_red_blue: [18000, 54000], leapstones: 700, fusions: 830, shards: 120000, juicers: [75, 225], gold: 36000, silver: 6000000, quality_taps: [72, 72], circulated: 860 } },
                    { label: 'Floor 80-89', cells: { honing_red_blue: [24000, 72000], leapstones: 950, fusions: 1150, shards: 160000, juicers: [105, 315], gold: 50000, silver: 8000000, quality_taps: [100, 100], circulated: 1200 } },
                    { label: 'Floor 90-99', cells: { honing_red_blue: [35000, 105000], leapstones: 1500, fusions: 1650, shards: 220000, juicers: [155, 465], gold: 72000, silver: 10000000, quality_taps: [144, 144], circulated: 1700 } },
                    { label: 'Floor 100', cells: { honing_red_blue: [56000, 168000], leapstones: 2400, fusions: 2400, shards: 380000, juicers: [256, 768], gold: 108000, silver: 20000000, quality_taps: [250, 250], circulated: 2800 } }
                ]
            }
        ];
        // ==========================================================


        let activeTab = 0;

        // Standardwerte
        const defaultMarket = {
            //T3
            'leapstones_t3': 35,
            'fusions_t3': 55,
            'honing_red_blue_t3': [0.45, 0.05],
            'shards_t3': 0.85,
            'juicers_t3': [17, 55, 148],
            'circulated_t3': 10,

            //T4
            'honing_red_blue': [2.7, 0.05],
            'leapstones': 12,
            'fusions': 102,
            'shards': 0.45,
            'juicers': [444, 150],
            'circulated': 50,

            'quality_taps': [800, 300],

        };

        let market = { ...defaultMarket };

        function loadMarket() {
            try {
                const s = localStorage.getItem('paradise_market');
                if (s) {
                    const parsed = JSON.parse(s);
                    if (typeof parsed === 'object' && parsed !== null) {
                        market = { ...defaultMarket }; // Start mit Defaults
                        for (const key in parsed) {
                            if (Array.isArray(defaultMarket[key]) && Array.isArray(parsed[key])) {
                                // Für Arrays: jedes Element einzeln prüfen
                                market[key] = defaultMarket[key].map((defVal, idx) => {
                                    const val = parsed[key][idx];
                                    return (val !== 0 && val !== null && val !== undefined) ? val : defVal;
                                });
                            } else {
                                // Für Einzelwerte
                                if (parsed[key] !== 0 && parsed[key] !== null && parsed[key] !== undefined) {
                                    market[key] = parsed[key];
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                console.warn('failed to load market from storage', e);
            }
        }

        function saveMarket() {
            try {
                localStorage.setItem('paradise_market', JSON.stringify(market));
            } catch (e) {
                console.warn('failed to save market', e);
            }
        }

        loadMarket();

        const tabsEl = document.getElementById('tabs');
        const cardEl = document.getElementById('card');

        function init() {
            TABLE_DATA.forEach((t, i) => {
                const btn = document.createElement('div'); btn.className = 'tab' + (i === 0 ? ' active' : ''); btn.textContent = t.title; btn.onclick = () => { setActive(i) }; tabsEl.appendChild(btn);
                // initialize market keys
                t.columns.forEach(c => { if (!(c.key in market)) market[c.key] = 0 });
            });
            renderActive();
        }

        function setActive(i) { activeTab = i;[...tabsEl.children].forEach((n, idx) => n.classList.toggle('active', idx === i)); renderActive(); }

        function renderActive() {
            const t = TABLE_DATA[activeTab];
            cardEl.innerHTML = '';

            // header: controls and legend
            const controls = document.createElement('div'); controls.className = 'controls';
            const info = document.createElement('div'); info.innerHTML = '<strong>' + t.title + '</strong> — enter market values in headers to calculate.'; controls.appendChild(info);
            const resetBtn = document.createElement('button'); resetBtn.textContent = 'Reset market values'; resetBtn.onclick = () => { Object.keys(market).forEach(k => { if (Array.isArray(market[k])) market[k] = market[k].map(() => 0); else market[k] = 0 }); saveMarket(); renderActive(); }; controls.appendChild(resetBtn);
            cardEl.appendChild(controls);

            // Build table inside a horizontal-scroll wrapper to avoid header stacking
            const tableWrapper = document.createElement('div'); tableWrapper.className = 'table-wrapper'; tableWrapper.style.overflowX = 'auto'; tableWrapper.style.paddingTop = '8px';
            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const trHead = document.createElement('tr');
            const thRow = document.createElement('th'); thRow.textContent = 'Floor / Range'; trHead.appendChild(thRow);

            // determine how many input parts each column needs (if some rows have arrays)
            const partsCount = {};
            t.columns.forEach(col => {
                let max = 0;
                t.rows.forEach(r => { const raw = r.cells[col.key]; if (Array.isArray(raw)) max = Math.max(max, raw.length); });
                partsCount[col.key] = Math.max(1, max);
                // initialize market structure if missing or adjust length

                if (!(col.key in market)) {
                    market[col.key] = partsCount[col.key] > 1 ? Array(partsCount[col.key]).fill(0) : 0;
                } else if (Array.isArray(market[col.key]) && market[col.key].length < partsCount[col.key]) {
                    market[col.key] = market[col.key].concat(Array(partsCount[col.key] - market[col.key].length).fill(0));
                } else if (!Array.isArray(market[col.key]) && partsCount[col.key] > 1) {
                    // existing single value -> expand to array keeping the single value as first element
                    market[col.key] = Array(partsCount[col.key]).fill(0).map((v, i) => i === 0 ? (market[col.key] || 0) : 0);
                }
            });

            // header inputs per column (support multiple inputs when column has multiple materials)
            t.columns.forEach(col => {
                const th = document.createElement('th'); th.className = 'header-input';
                const label = document.createElement('div'); label.textContent = col.label; label.style.fontWeight = '600'; label.style.fontSize = '13px';
                th.appendChild(label);


                if (col.key === 'gold') {
                    const fixed = document.createElement('div'); fixed.textContent = '1'; fixed.className = 'small'; th.appendChild(fixed);
                } else if (partsCount[col.key] <= 1) {
                    const inp = document.createElement('input'); inp.className = 'market'; inp.type = 'number'; inp.min = '0'; inp.step = '1';
                    inp.value = Array.isArray(market[col.key]) ? (market[col.key][0] || '') : (market[col.key] || '');
                    inp.oninput = (e) => { market[col.key] = parseFloat(e.target.value) || 0; saveMarket(); updateComputedValues(); };
                    th.appendChild(inp);
                } else {
                    const rowDiv = document.createElement('div'); rowDiv.style.display = 'flex'; rowDiv.style.gap = '6px'; rowDiv.style.justifyContent = 'center';
                    for (let i = 0; i < partsCount[col.key]; i++) {
                        const inp = document.createElement('input'); inp.className = 'market'; inp.type = 'number'; inp.min = '0'; inp.step = '0.01'; inp.dataset.idx = i; inp.style.width = '70px';
                        inp.value = (Array.isArray(market[col.key]) ? (market[col.key][i] || '') : '');
                        inp.oninput = (e) => { const idx = parseInt(e.target.dataset.idx); market[col.key][idx] = parseFloat(e.target.value) || 0; saveMarket(); updateComputedValues(); };
                        rowDiv.appendChild(inp);
                    }
                    th.appendChild(rowDiv);
                }

                trHead.appendChild(th);
            });
            thead.appendChild(trHead); table.appendChild(thead);

            const tbody = document.createElement('tbody');

            t.rows.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                const tdLabel = document.createElement('td'); tdLabel.textContent = row.label; tdLabel.style.textAlign = 'left'; tr.appendChild(tdLabel);

                // compute cell values
                const computedValues = [];
                t.columns.forEach(col => {
                    const raw = row.cells[col.key];
                    const value = computeColumnValue(raw, col.key);
                    const count = normalizeCellToNumber(raw);
                    computedValues.push({ count, value });
                });

                // find max value for heat
                const maxVal = Math.max(...computedValues.map(c => c.value));

                computedValues.forEach((c, ci) => {
                    const td = document.createElement('td');
                    td.innerHTML = '<div class="cell-count">' + displayRaw(row.cells[t.columns[ci].key]) + '</div>' +
                        '<div class="cell-value">' + formatNumber(c.value) + '</div>';
                    // heat color
                    td.style.background = heatColor(c.value, maxVal);
                    td.className = 'heat';
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });

            table.appendChild(tbody);
            tableWrapper.appendChild(table);
            cardEl.appendChild(tableWrapper);

            const legend = document.createElement('div'); legend.className = 'legend';
            const low = document.createElement('div'); low.className = 'box'; low.style.background = 'linear-gradient(90deg,#ffe9e9,#ffdada)'; legend.appendChild(low); legend.appendChild(document.createTextNode('Low'));
            const mid = document.createElement('div'); mid.className = 'box'; mid.style.background = 'linear-gradient(90deg,#fff7e6,#fff0cc)'; legend.appendChild(mid); legend.appendChild(document.createTextNode('Medium'));
            const high = document.createElement('div'); high.className = 'box'; high.style.background = 'linear-gradient(90deg,#e9ffef,#d9ffe6)'; legend.appendChild(high); legend.appendChild(document.createTextNode('High'));
            cardEl.appendChild(legend);

            const note = document.createElement('div'); note.className = 'note'; note.innerHTML = '<strong>Note:</strong> If a cell contains multiple different materials that live in the same column, the header will show multiple inputs. The UI multiplies each material count by its respective header value.';
            cardEl.appendChild(note);

            updateComputedValues();
        }

        // compute total value for a column cell, supporting multiple-part cells
        function computeColumnValue(raw, colKey) {
            if (raw == null) return 0;
            // gold column has implicit market value of 1 (1 gold = 1)
            if (colKey === 'gold') {
                const count = normalizeCellToNumber(raw);
                return count * 1;
            }
            if (Array.isArray(raw)) {
                let total = 0;
                for (let i = 0; i < raw.length; i++) {
                    const partCount = Number(raw[i] || 0);
                    const marketVal = Array.isArray(market[colKey]) ? (market[colKey][i] || 0) : (market[colKey] || 0);
                    total += marketVal * partCount;
                }
                return total;
            }
            // raw is single number or string -> multiply by single market value
            const count = normalizeCellToNumber(raw);
            const marketVal = Array.isArray(market[colKey]) ? market[colKey].reduce((s, x) => s + (Number(x) || 0), 0) : (market[colKey] || 0);
            return marketVal * count;
        }

        function updateComputedValues() {
            // Only update computed numeric values + heatmap in the currently-rendered table without rebuilding the whole DOM.
            const t = TABLE_DATA[activeTab];
            const table = cardEl.querySelector('table');
            if (!table) return;
            const tbody = table.querySelector('tbody');
            if (!tbody) return;
            const rowEls = Array.from(tbody.querySelectorAll('tr'));

            rowEls.forEach((tr, rowIndex) => {
                const rowData = t.rows[rowIndex];
                if (!rowData) return; // defensive

                // compute values for this row
                const computedValues = t.columns.map(col => {
                    const raw = rowData.cells[col.key];
                    const value = computeColumnValue(raw, col.key);
                    const count = normalizeCellToNumber(raw);
                    return { count, value };
                });

                const maxVal = Math.max(...computedValues.map(c => c.value));

                // tds: [label, col1, col2, ..., rowTotal]
                const tds = Array.from(tr.querySelectorAll('td'));
                if (tds.length < 2) return;

                // update each column cell
                for (let ci = 0; ci < computedValues.length; ci++) {
                    const td = tds[1 + ci];
                    if (!td) continue;
                    td.innerHTML = '<div class="cell-count">' + displayRaw(rowData.cells[t.columns[ci].key]) + '</div>' +
                        '<div class="cell-value">' + formatNumber(computedValues[ci].value) + '</div>';
                    td.style.background = heatColor(computedValues[ci].value, maxVal);
                }

            });
        }

        // helpers
        function normalizeCellToNumber(raw) {
            if (raw == null) return 0;
            if (Array.isArray(raw)) return raw.reduce((s, x) => s + Number(x || 0), 0);
            if (typeof raw === 'string') {
                // try to parse numbers inside string like "6 / 18" -> sum 24? User requested "add them" if multiple materials in a column
                const nums = raw.match(/-?\d+(?:[\.,]\d+)?/g);
                if (!nums) return 0;
                return nums.map(n => Number(n.replace(',', '.'))).reduce((s, x) => s + x, 0);
            }
            return Number(raw) || 0;
        }

        function formatNumber(n) {
            if (!n) return '0';
            if (Math.abs(n) >= 1000000) return Math.round(n).toLocaleString();
            return (Math.round(n * 100) / 100).toLocaleString();
        }

        function displayRaw(raw) {
            if (raw == null) return '0';
            if (Array.isArray(raw)) return raw.join(' + ');
            return String(raw);
        }

        // heatColor: produce a subtle background based on proportion to max
        function heatColor(value, max) {
            if (max <= 0) return 'transparent';
            const ratio = value / (max || 1);
            // ratio 0 -> light red, 0.5 -> pale yellow, 1 -> pale green
            if (ratio <= 0.33) {
                return 'linear-gradient(180deg,#fff1f0,#ffecec)';
            } else if (ratio <= 0.66) {
                return 'linear-gradient(180deg,#fffbf0,#fff6e6)';
            } else {
                return 'linear-gradient(180deg,#f1fff6,#e6fff0)';
            }
        }

        init();
    </script>
</body>

</html>